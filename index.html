<!DOCTYPE html>
<html lang="am">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ultimate Kids Math Challenge!</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap');

  :root {
    --primary-color: #3498db;
    --secondary-color: #2ecc71;
    --wrong-color: #e74c3c;
    --light-bg: #ecf0f1;
    --dark-text: #2c3e50;
  }

  body {
    background: linear-gradient(135deg, #6dd5ed 0%, #2193b0 100%);
    font-family: 'Nunito', sans-serif;
    padding: 20px;
    overflow: hidden;
    color: var(--dark-text);
  }

  .game-wrapper {
    display: flex;
    max-width: 900px;
    margin: 20px auto;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 25px;
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.2);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.18);
  }

  /* --- Player Sidebar --- */
  .player-sidebar {
    width: 250px;
    padding: 20px;
    border-right: 2px solid var(--light-bg);
  }
  .player-sidebar h2 {
    text-align: center;
    margin-top: 0;
  }
  .player-card {
    margin-bottom: 15px;
    padding: 10px;
    border-radius: 10px;
    transition: all 0.3s ease;
  }
  .player-card.active {
    background-color: var(--primary-color);
    color: white;
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(52, 152, 219, 0.5);
  }
  .player-info {
    display: flex;
    justify-content: space-between;
    font-weight: bold;
    font-size: 1.1em;
  }
  .progress-bar-container {
    background-color: #e0e0e0;
    border-radius: 10px;
    height: 10px;
    margin-top: 5px;
    overflow: hidden;
  }
  .progress-bar {
    width: 0%;
    height: 100%;
    background-color: var(--secondary-color);
    transition: width 0.5s ease-in-out;
  }
  .player-card.active .progress-bar {
    background-color: white;
  }
  .player-card.tied {
      background-color: #f39c12; /* Orange for tied players */
      color: white;
  }

  /* --- Main Game Area --- */
  .game-container {
    flex-grow: 1;
    padding: 20px 40px;
    text-align: center;
  }

  #current-player-turn {
    font-size: 1.5em;
    font-weight: bold;
    min-height: 2em; /* To prevent jump */
  }

  #question {
    font-size: 2.2em;
    min-height: 100px;
    margin: 20px 0;
    color: var(--primary-color);
    font-weight: 700;
  }

  input[type="number"] {
    width: 50%;
    padding: 12px;
    border-radius: 10px;
    border: 2px solid #ddd;
    text-align: center;
    font-size: 1.5em;
    margin-bottom: 15px;
  }
  
  button {
    background-color: var(--secondary-color);
    color: white;
    border: none;
    padding: 12px 30px;
    border-radius: 10px;
    font-size: 18px;
    cursor: pointer;
    transition: background-color 0.3s, transform 0.2s;
  }
  button:hover {
    background-color: #27ae60;
    transform: scale(1.05);
  }
  #muteBtn {
    background-color: var(--wrong-color); position: fixed;
    top: 15px; right: 15px; z-index: 100;
  }

  /* --- Winner Screen --- */
  #winner-screen {
    display: none; /* Hidden by default */
    text-align: center;
    padding: 40px;
  }
  #winner-name {
    font-size: 3em;
    color: #f1c40f;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
  }
  #dancing-char {
    width: 250px;
    height: 250px;
    margin: 20px auto;
  }

  /* --- Animations --- */
  .star {
    position: absolute; top: -20px; color: gold; font-size: 24px;
    animation: fall 3s linear; pointer-events: none;
  }
  @keyframes fall {
    to { transform: translateY(100vh); opacity: 0; }
  }
  .shake {
    animation: shake 0.5s;
  }
  @keyframes shake {
    10%, 90% { transform: translate3d(-1px, 0, 0); }
    20%, 80% { transform: translate3d(2px, 0, 0); }
    30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
    40%, 60% { transform: translate3d(4px, 0, 0); }
  }

  @media (max-width: 768px) {
    .game-wrapper {
        flex-direction: column;
    }
    .player-sidebar {
        width: 100%;
        border-right: none;
        border-bottom: 2px solid var(--light-bg);
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
    }
    .player-card {
        width: 120px;
    }
  }

</style>
</head>
<body>

<audio id="background-music" src="abdu-kiyar-bye-bye.mp3" loop></audio>

<button id="muteBtn" onclick="toggleMute()">Mute</button>

<div class="game-wrapper">
  <div class="player-sidebar" id="player-sidebar">
    <h2>Players</h2>
  </div>

  <div class="game-container" id="game-container">
    <h1 id="current-player-turn"></h1>
    <div id="question-box">
      <h3 id="question"></h3>
      <input type="number" id="answer" placeholder="·àò·àç·àµ·àÖ·äï ·ä•·ãö·àÖ ·ä†·àµ·åà·â£">
      <br>
      <button onclick="checkAnswer()">Submit</button>
    </div>
  </div>

  <div id="winner-screen">
    <h1>üèÜ ·àª·àù·çí·ãÆ·äï! üèÜ</h1>
    <img id="dancing-char" src="https://media.tenor.com/a2sP52-0i7EAAAAi/minions-dance.gif" alt="Dancing Character">
    <h2 id="winner-name"></h2>
    <button onclick="initializeGame()">Play Again</button>
  </div>
</div>

<script>
// --- DOM Elements ---
const gameWrapper = document.querySelector('.game-wrapper');
const gameContainer = document.getElementById('game-container');
const winnerScreen = document.getElementById('winner-screen');
const playerSidebar = document.getElementById('player-sidebar');
const currentPlayerTurnEl = document.getElementById('current-player-turn');
const questionEl = document.getElementById('question');
const answerEl = document.getElementById('answer');
const winnerNameEl = document.getElementById('winner-name');
const muteBtn = document.getElementById('muteBtn');
const backgroundMusic = document.getElementById('background-music');

// --- Game State & Config ---
const playerNames = ["Faruk", "Mursi", "Veronica", "Selamn", "Hafiz"];
let players = [];
let currentPlayerIndex = 0;
let correctAnswer = 0;
let isMuted = false;
let winnerSoundInterval = null;
const TOTAL_QUESTIONS_PER_PLAYER = 10;
let isTieBreakerMode = false;
let tiedPlayers = [];

// --- Compliments & Word Problems (unchanged) ---
const compliments = [
  "·åé·â†·ãù!", "·àç·ä≠ ·äê·àÖ!", "·â†·å£·àù ·å•·à©!", "·â†·âµ·ä≠·ä≠·àç!", "·ä†·äï·â∞ ·â†·å£·àù ·åé·â†·ãù ·äê·àÖ!",
  "·çà·å£·äï ·äê·àÖ!", "·ä§·ä≠·à∞·àà·äï·âµ!", "·ä†·äï·â∞ ·åÄ·åç·äì ·äê·àÖ!", "·å•·à© ·ä†·àµ·â∞·à≥·à∞·â• ·äê·ãç!", "·ãã·ãç!",
  "·ä†·åà·äò·ä∏·ãç!", "·ä†·äï·â∞ ·äÆ·ä®·â• ·äê·àÖ!", "·åç·à©·àù ·äê·ãç!"
];

// Re-using the Amharic word problems
const amharicWordProblems = [
  { q: "·çã·à©·ä≠ 5 ·çñ·àù ·ä†·àà·ãç·ç§ ·àô·à≠·à≤ 3 ·å®·àò·à®·àà·âµ·ç¢ ·çã·à©·ä≠ ·ä†·àÅ·äï ·àµ·äï·âµ ·çñ·àù ·ä†·àà·ãç?", a: 8 },
  { q: "·ãõ·çç ·àã·ã≠ 10 ·ãà·çé·âΩ ·äê·â†·à©·ç¢ 4·â± ·â†·à®·à©·ç¢ ·àµ·äï·âµ ·ãà·çé·âΩ ·âÄ·à©?", a: 6 },
  { q: "·â¨·àÆ·äí·ä´ 2 ·à≥·å•·äñ·âΩ ·ä†·àè·âµ·ç¢ ·ä•·ã´·äï·ã≥·äï·ã± ·à≥·å•·äï ·ãç·àµ·å• 6 ·ä•·à≠·à≥·à∂·âΩ ·ä†·àâ·ç¢ ·â†·å†·âÖ·àã·àã ·àµ·äï·âµ ·ä•·à≠·à≥·à∂·âΩ ·ä†·àâ?", a: 12 },
  { q: "·à∞·àã·àù·äï 15 ·â•·à≠·â±·ä´·äï ·åà·ãù·â∂ 5·â±·äï ·àà·åì·ã∞·äû·âπ ·à∞·å†·ç¢ ·àµ·äï·âµ ·â•·à≠·â±·ä´·äï ·âÄ·à®·ãç?", a: 10 },
  { q: "·ä†·äï·ãµ ·àò·ä™·äì 4 ·åé·àõ·ãé·âΩ ·ä†·àâ·âµ·ç¢ 3 ·àò·ä™·äì·ãé·âΩ ·â†·ãµ·àù·à© ·àµ·äï·âµ ·åé·àõ·ãé·âΩ ·ä†·àè·â∏·ãç?", a: 12 },
  { q: "·â†·ä†·äï·ãµ ·ä≠·çç·àç 7 ·ãà·äï·ã∂·âΩ ·ä•·äì 8 ·à¥·â∂·âΩ ·ä†·àâ·ç¢ ·â†·ä≠·çç·àâ ·ãç·àµ·å• ·â†·å†·âÖ·àã·àã ·àµ·äï·âµ ·â∞·àõ·à™·ãé·âΩ ·ä†·àâ?", a: 15 }
];

// Array to track question history for the current round
let questionHistory = [];

// --- Helper Functions ---
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function speak(text, lang = "am-ET") {
  if (isMuted) return;
  const utter = new SpeechSynthesisUtterance(text);
  utter.lang = lang;
  speechSynthesis.speak(utter);
}

function toggleMute() {
  isMuted = !isMuted;
  backgroundMusic.muted = isMuted;
  muteBtn.innerText = isMuted ? "Unmute" : "Mute";
  if (isMuted) {
    speechSynthesis.cancel();
    if(winnerSoundInterval) clearInterval(winnerSoundInterval);
    backgroundMusic.pause();
  } else {
      if (backgroundMusic.paused) {
          backgroundMusic.volume = 0.1;
          backgroundMusic.play().catch(e => console.log("Music play prevented on unmute:", e));
      }
  }
}

// --- Game Flow Functions ---
function renderPlayerList() {
    playerSidebar.innerHTML = '<h2>Players</h2>';
    players.forEach((player, index) => {
        const card = document.createElement('div');
        card.className = 'player-card';
        
        // Active and Tied Status
        const isActive = !isTieBreakerMode && index === currentPlayerIndex;
        const isCurrentlyTied = isTieBreakerMode && tiedPlayers.includes(player);

        if (isActive) {
            card.classList.add('active');
        } else if (isCurrentlyTied) {
            card.classList.add('tied');
        } else if (player.questionCount >= TOTAL_QUESTIONS_PER_PLAYER && !isTieBreakerMode) {
            card.style.opacity = '0.5';
        }

        const progress = (player.questionCount / TOTAL_QUESTIONS_PER_PLAYER) * 100;
        card.innerHTML = `
            <div class="player-info">
                <span>${player.name}</span>
                <span>${player.score}</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" style="width: ${progress}%;"></div>
            </div>
        `;
        playerSidebar.appendChild(card);
    });
}

function initializeGame() {
    if(winnerSoundInterval) clearInterval(winnerSoundInterval);
    players = playerNames.map(name => ({ name, score: 0, questionCount: 0, tieBreakerCorrect: 0 }));
    currentPlayerIndex = 0;
    isTieBreakerMode = false;
    tiedPlayers = [];
    questionHistory = [];
    
    winnerScreen.style.display = 'none';
    gameWrapper.style.display = 'flex';
    
    backgroundMusic.muted = isMuted;
    backgroundMusic.pause(); 
    
    startTurn();
}

function startTurn() {
    if (isGameOver()) {
        checkAndStartTieBreaker();
        return;
    }
    
    // Skip finished players only in main game mode
    if (!isTieBreakerMode) {
        while (players[currentPlayerIndex].questionCount >= TOTAL_QUESTIONS_PER_PLAYER) {
            currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
        }
    }
    
    renderPlayerList();
    const currentPlayer = players[currentPlayerIndex];
    
    if (isTieBreakerMode) {
        currentPlayerTurnEl.innerText = `${currentPlayer.name}'s Tie-Breaker Question!`;
    } else {
        currentPlayerTurnEl.innerText = `${currentPlayer.name}'s Turn (${currentPlayer.questionCount + 1}/${TOTAL_QUESTIONS_PER_PLAYER})`;
    }
    
    generateQuestion(currentPlayer.questionCount);
}

/**
 * Generates a random, non-repetitive math question with increasing difficulty.
 * @param {number} qNum - The current question number (0 to 9) to determine difficulty.
 */
function generateQuestion(qNum) {
    answerEl.value = "";
    answerEl.focus();

    let questionText = "";
    let a, b, result;
    let difficultyLevel = isTieBreakerMode ? 4 : Math.floor(qNum / (TOTAL_QUESTIONS_PER_PLAYER / 4)) + 1;
    
    let isUnique = false;
    while (!isUnique) {
        // Default to a hard-coded word problem at the start of a round for variety
        if (!isTieBreakerMode && qNum === 0 && Math.random() < 0.3) {
            const problem = amharicWordProblems[getRandomInt(0, amharicWordProblems.length - 1)];
            questionText = problem.q;
            correctAnswer = problem.a;
        } else {
            switch (difficultyLevel) {
                case 1: // Easy: Basic Addition/Subtraction (1-10)
                    a = getRandomInt(1, 10);
                    b = getRandomInt(1, 10);
                    if (Math.random() < 0.5) { // Addition
                        correctAnswer = a + b; questionText = `${a} + ${b}`;
                    } else { // Subtraction
                        correctAnswer = Math.max(a, b) - Math.min(a, b); questionText = `${Math.max(a, b)} - ${Math.min(a, b)}`;
                    }
                    break;
                case 2: // Medium: Mixed Operations (Addition/Subtraction/Simple Multiplication)
                    a = getRandomInt(10, 30);
                    b = getRandomInt(5, 20);
                    const op2 = ["+", "-", "√ó"][getRandomInt(0, 2)];
                    if (op2 === "+") { correctAnswer = a + b; questionText = `${a} + ${b}`; }
                    if (op2 === "-") { correctAnswer = Math.max(a, b) - Math.min(a, b); questionText = `${Math.max(a, b)} - ${Math.min(a, b)}`; }
                    if (op2 === "√ó") { a = getRandomInt(2, 10); b = getRandomInt(2, 8); correctAnswer = a * b; questionText = `${a} √ó ${b}`; }
                    break;
                case 3: // Hard: Mixed Operations (Larger Numbers, Multiplication, Simple Division)
                    a = getRandomInt(30, 80);
                    b = getRandomInt(10, 50);
                    const op3 = ["+", "-", "√ó", "√∑"][getRandomInt(0, 3)];
                    if (op3 === "+") { correctAnswer = a + b; questionText = `${a} + ${b}`; }
                    if (op3 === "-") { correctAnswer = Math.max(a, b) - Math.min(a, b); questionText = `${Math.max(a, b)} - ${Math.min(a, b)}`; }
                    if (op3 === "√ó") { a = getRandomInt(5, 12); b = getRandomInt(5, 12); correctAnswer = a * b; questionText = `${a} √ó ${b}`; }
                    if (op3 === "√∑") { a = getRandomInt(2, 10); b = getRandomInt(2, 10); result = a * b; correctAnswer = b; questionText = `${result} √∑ ${a}`; }
                    break;
                case 4: // Tie-Breaker/Very Hard: Two-step operations, larger numbers
                    const a1 = getRandomInt(5, 15);
                    const b1 = getRandomInt(5, 15);
                    const c1 = getRandomInt(2, 5);
                    const opA = ["+", "-"][getRandomInt(0, 1)];
                    const opB = ["√ó", "+"][getRandomInt(0, 1)];
                    
                    if (opA === "+" && opB === "√ó") { // e.g. (a + b) x c
                        correctAnswer = (a1 + b1) * c1;
                        questionText = `(${a1} + ${b1}) √ó ${c1}`;
                    } else if (opA === "-" && opB === "√ó") { // e.g. (a - b) x c
                        correctAnswer = (Math.max(a1, b1) - Math.min(a1, b1)) * c1;
                        questionText = `(${Math.max(a1, b1)} - ${Math.min(a1, b1)}) √ó ${c1}`;
                    } else { // e.g. a x b + c
                        correctAnswer = (a1 * b1) + c1;
                        questionText = `${a1} √ó ${b1} + ${c1}`;
                    }
                    break;
            }
        }
        
        // Check if question is already in history (prevents immediate repetition)
        const newQuestionKey = `${questionText}=${correctAnswer}`;
        if (!questionHistory.includes(newQuestionKey)) {
            isUnique = true;
            questionHistory.push(newQuestionKey);
            // Limit history size to prevent memory issues (e.g., last 20 questions)
            if (questionHistory.length > 20) {
                questionHistory.shift(); 
            }
        }
    }

    questionEl.innerText = questionText;
    const speakText = questionText.replace('√ó', ' ·à≤·â£·ãõ ').replace('√∑', ' ·à≤·ä´·çà·àç ').replace('+', ' ·à≤·ã∞·àò·à≠ ').replace('-', ' ·à≤·âÄ·äê·àµ ').replace('(', '').replace(')', '');
    speak("·å•·ã´·âÑ·ç• " + speakText);
}

function checkAnswer() {
    if (backgroundMusic.paused && !isMuted) {
        backgroundMusic.volume = 0.1;
        backgroundMusic.play().catch(e => {
            console.log("Music autoplay prevented by browser:", e);
        });
    }

    const userAnswer = parseInt(answerEl.value, 10);
    const questionBox = document.getElementById('question-box');
    const currentPlayer = players[currentPlayerIndex];

    if (isNaN(userAnswer)) {
        speak("·ä•·â£·ä≠·àÖ ·âÅ·å•·à≠ ·ä†·àµ·åà·â£!");
        questionBox.classList.add('shake');
        setTimeout(() => questionBox.classList.remove('shake'), 500);
        return;
    }

    if (userAnswer === correctAnswer) {
        // Correct Answer Logic
        const randomCompliment = compliments[getRandomInt(0, compliments.length - 1)];
        speak(randomCompliment);
        createStars();
        
        if (isTieBreakerMode) {
            currentPlayer.tieBreakerCorrect++;
            speak(`${currentPlayer.name}, ·â†·âµ·ä≠·ä≠·àç ·àò·àç·à∞·àÉ·àç!`);
            // Immediate check and progression for tie-breaker
            if (tiedPlayers.length === 1) { // If only one player is left
                endGame(tiedPlayers[0].name);
            } else {
                nextTieBreakerTurn();
            }
            return; // Exit here, tie-breaker logic handles the next step
        } else {
            currentPlayer.score++;
            currentPlayer.questionCount++;
        }
    } else {
        // Wrong Answer Logic (New Requirement)
        speak("·âµ·ä≠·ä≠·àç ·ä†·ã≠·ã∞·àà·àù!");
        questionBox.classList.add('shake');
        setTimeout(() => questionBox.classList.remove('shake'), 500);

        if (isTieBreakerMode) {
            // Player is eliminated from the tie-breaker round
            speak(`${currentPlayer.name} ·ä®·ãç·ãµ·ãµ·à© ·ãà·å•·â∞·àÉ·àç·ç¢`);
            tiedPlayers = tiedPlayers.filter(p => p !== currentPlayer);
            if (tiedPlayers.length === 1) { // Only one player remains
                endGame(tiedPlayers[0].name);
                return;
            } else if (tiedPlayers.length === 0) { // All eliminated (very rare tie)
                endGame("No one");
                return;
            }
        } else {
            currentPlayer.questionCount++; // Still count the question attempt
        }
    }

    // Normal Game Flow: Pass turn to the next player
    nextTurn();
}

function nextTurn() {
    // Check for game end condition before moving to next player
    if (isGameOver() && !isTieBreakerMode) {
        checkAndStartTieBreaker();
        return;
    }

    // Move to the next player
    currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
    
    // Skip players who have finished all their questions (only in main game)
    if (!isTieBreakerMode) {
        let originalIndex = currentPlayerIndex;
        while (players[currentPlayerIndex].questionCount >= TOTAL_QUESTIONS_PER_PLAYER) {
            currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
            // If we circled back to the starting point, all players must be finished.
            if (currentPlayerIndex === originalIndex) {
                checkAndStartTieBreaker();
                return;
            }
        }
    }
    
    startTurn();
}

function isGameOver() {
    return players.every(p => p.questionCount >= TOTAL_QUESTIONS_PER_PLAYER);
}

// --- Tie Breaker Logic ---
function checkAndStartTieBreaker() {
    const scores = players.map(p => p.score);
    const highScore = Math.max(...scores);
    
    tiedPlayers = players.filter(p => p.score === highScore && p.score > 0);
    
    if (tiedPlayers.length > 1) {
        // Start Tie-Breaker Mode
        isTieBreakerMode = true;
        // Shuffle the tied players to randomize the turn order
        // This is a simple shuffle (Fisher-Yates is better but this is sufficient)
        tiedPlayers.sort(() => Math.random() - 0.5);
        
        // Reset player index to the first tied player
        currentPlayerIndex = players.findIndex(p => p === tiedPlayers[0]);
        
        speak(`·ãç·ãµ·ãµ·à© ·â†·ä•·ä©·àç ·äê·å•·â• ·â∞·å†·äì·âã·àç·ç¢ ·ä†·àÅ·äï ·ã®·ä•·ä©·àç ·äê·å•·â• ·à∞·â£·à™ ·å•·ã´·âÑ·ãé·âΩ ·ã≠·âÄ·à≠·â£·àâ! ${tiedPlayers.map(p => p.name).join(', ')} ·â∞·ãò·åã·åÅ!`);
        startTurn();
    } else if (tiedPlayers.length === 1) {
        // One winner found
        endGame(tiedPlayers[0].name);
    } else {
        // No score or no players left
        endGame("No one");
    }
}

function nextTieBreakerTurn() {
    // Find the current player's index within the 'players' array
    const currentIndexInPlayers = players.findIndex(p => p === tiedPlayers[0]);
    
    // Cycle the `tiedPlayers` array to make the next player the first element
    const nextPlayer = tiedPlayers.shift(); 
    tiedPlayers.push(nextPlayer); 
    
    // Update the main index to the new current player
    currentPlayerIndex = players.findIndex(p => p === tiedPlayers[0]);
    
    // Check for winner *after* the turn cycle in case only one is left
    if (tiedPlayers.length === 1) {
        endGame(tiedPlayers[0].name);
    } else {
        startTurn();
    }
}


function endGame(winnerName) {
    backgroundMusic.pause();
    
    const winnerMessage = winnerName !== "No one"
        ? `·ä†·äï·â∞ ·àª·àù·çí·ãÆ·äï ·äê·àÖ! ·â†·å£·àù ·ä†·àµ·åà·à´·àö ·äê·ãç! ·ä•·äï·ä≥·äï ·ã∞·àµ ·ä†·àà·àÖ ${winnerName}!`
        : "·å®·ãã·â≥·ãç ·â∞·å†·äì·âã·àç·ç¢ ·àà·àö·âÄ·å•·àà·ãç ·åä·ãú ·àò·àç·ä´·àù
